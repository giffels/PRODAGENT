#!/usr/bin/env python
"""
_prodAgent-config_

Command line tool for generating a ProdAgentConfiguration.

Requires that PRODAGENT_CONFIG be set to provide the location
of the configuration file being created

"""

import os
import socket
import sys
import getopt
import time

from ProdAgentCore.Configuration import ProdAgentConfiguration

_Timestamp = time.strftime("%d-%M-%Y")

def usage():
    """print usage info"""
    strg = "Usage: prodAgent-new-config <options>\n"
    strg += " --config=<configFileName> : Config will be written into\n"
    strg += "   file provided, else it will be written to $PRODAGENT_CONFIG\n"
    strg += " --component=comp1,comp2,comp3\n"
    strg += "  If no options are provided the default component list is used\n"
    strg += "  If --components is supplied, the list of components is\n"
    strg += "  taken to be a comma seperated list of components to be used\n"
    
    print strg

valid = ['components=', "config="]
try:
    opts, args = getopt.getopt(sys.argv[1:], "", valid)
except getopt.GetoptError, ex:
    print str(ex)
    usage()
    sys.exit(1)

configFile = None
componentList = []

for opt, arg in opts:
    if opt == "--components":
        compList = arg.split(',')
        for item in compList:
            componentList.append(item.strip())
    if opt == "--config":
        configFile = arg



if configFile == None:
    configFile = os.environ.get("PRODAGENT_CONFIG", None)
    if configFile == None:
        print "Configfile not found:"
        print "Must be provided either via $PRODAGENT_CONFIG env var"
        print "Or via --config option"
        sys.exit(1)

homeDir=os.environ.get("PRODAGENT_ROOT")
if  homeDir == None:
    print "PRODAGENT_ROOT variable not found:"
    print "Must be provided either via $PRODAGENT_ROOT env var"
    sys.exit(1)


BOSSDIR=os.environ.get("BOSSDIR")
if  BOSSDIR == None:
    print "WARNING: BOSSDIR variable not found"
    BOSSDIR=""

coreFields = {
    #  //
    # // Core pieces: ProdAgent, ProdAgentDB, MessageService, JobStates
    #//               Local scope DBS
    "ProdAgent": {
    "ProdAgentWorkDir": os.getcwd(),
    "ProdAgentName" : "ProdAgent@%s" % socket.gethostname(),
    "ProdAgentCert" : "/home/fvlingen/.globus/client.pem",
    "ProdAgentKey"  : "/home/fvlingen/.globus/clientkey.pem",
    },
    
    "ProdAgentDB": {
    'dbName':'ProdAgentDB',
    'host':'localhost',
    'user':'ProdAgentUser',
    'passwd':'ProdAgentPass',
    'socketFileLocation':'/var/lib/mysql/mysql.sock',
    'portNr':'',
    'refreshPeriod' : 4*3600 ,
    'maxConnectionAttempts' : 5,
    'dbWaitingTime' : 10 ,
    'schemaLocation': "$PRODAGENT_ROOT/share/ProdAgentDB.sql"
    },

    "BOSS": {
    # BossConfig.clad
    'tmpDir':'/tmp',
    'minUpdInt':30,
    'maxUpdInt':180,
    'maxRetry':3,
    'monaLisaUrl':'',
    # MySQLConfig.clad
    'domain':'localdomain',
    'guestUser':'ProdAgentGuest',
    'guestPasswd':'ProdAgentGuestPasswd',
    'realtimeMonitor':'yes',
    'configDir':'',
    'clarensKey':'',
    'clarensCert':'',
    'clarensUrl':'',
    'clarensProxy':'',
    'rtHost':socket.gethostname(),
    'rtDomain':socket.getfqdn(),
    'rtPortNr':'3306'},
    
    "MessageService" : {
    "pollInterval" : 5, 
    },

    "JobStates" : {
    "maxRetries":10
    },

    'LocalDBS' :{
    "DBSURL": "http://cmsdoc.cern.ch/cms/test/aprom/DBS/CGIServer/prodquery",
    "DBSAddress": None,
    "DBSType" : "CGI",
    },
    
    }# end core Fields


componentFields = {

    "RequestInjector" : {
    "ComponentDir" : None,
    },

    "JobCreator" : {
    "ComponentDir" : None,
    "CreatorName" : "testCreator",
    "CreatorPluginConfig": os.path.join(os.path.dirname(configFile), "CreatorPluginConfig.xml"),

    },
    "JobSubmitter" : {
    "ComponentDir" : None,
    "SubmitterName" : "noSubmit",
    "SubmitterPluginConfig" : os.path.join(os.path.dirname(configFile),"SubmitterPluginConfig.xml"),
    },

    "DBSInterface" : {
    "ComponentDir" : None,
    "DBSDataTier" : "GEN,SIM,DIGI,HLT,RECO,AOD,RAW,USER",
    # Local DBS settings come from LocalDBS core block 
    },

    "DLSInterface" : {
    "ComponentDir" : None,
    "DLSAddress" : None,
    "DLSType" : None,
    },

    "JobTracking" : {
    "ComponentDir" : None,
    "BOSSDIR" : BOSSDIR,
    "BOSSPATH" : None,
    "BOSSVERSION" : None,
    "PollInterval" : 10,
    "jobsToPoll" : 100,
    },

    'MergeSensor' : {
    "ComponentDir" : None,
    "StartMode" : "warm",
    "PollInterval": 30,
    "MergeFileSize" : 1000000000,
    "MergeSiteWhitelist" : None,
    "MergeSiteBlacklist" : None,
    "FastMerge": "no"
    # Local DBS settings come from LocalDBS core block 
    },

    'ErrorHandler' : {
    "ComponentDir" : None,
    "MaxCacheDirSizeMB":80,
    "DelayFactor":100
    
    },
    'JobCleanup'   : {
    "ComponentDir" : None,
    "FailureArchive":None,
    "SuccessArchive":None

    },
    'AdminControl' : {
    "ComponentDir" : None,
    "AdminControlHost" : "127.0.0.1",
    "AdminControlPort" : 8081,
    },
    "StatTracker" : {
    "ComponentDir" : None,
    },
    "PhEDExInterface" : {
    "ComponentDir" : None,
    "PhEDExDropBox" : None,
    },
    "ProdMgrInterface" : {
    "ComponentDir" : None,
    }

    }# end componentFields

#  //
# // Map of block names to comments for the block.
#//  Comments get inserted into the config file as XML comments
#  //and provide docs for people who want to poke around in there
# //
#//
comments = {
    "ProdAgentDB" : \
"""
You should only supply either the portNr OR socketFileLocation
""",
   "BOSS" : \
"""
Please look over these parameters carefully.
If you are not using the Clarens based web service for database
communication you can leave the Clarens entries empty.
The BOSS database names will be derived from the ProdAgent DB name
""",
   "JobSubmitter" : \
"""
SubmitterName values you can use: condorg, condor, lcg, lsf, lxb1125, and noSubmit
""",
   "ErrorHandler" : \
"""
MaxCacheDirSizeMB : The maximum size a cache dir can have 
before it is pruned, to prevent taking up to much space.
If it reaches this size the next submision/run failure will
trigger an intermediate cleanup event.
DelayFactor: A factor (in seconds) multiplied with the number of failure
of the job that is used to submit new submission events with a delay.
""",
  "JobStates"      : \
"""
MaxRetries: The maximum number of retries for a certain job(spec). If there
is a failure in creation,submission,running,etc.. a failure event will be triggered
and the job will restart (retry). Once the maximum is reached a general job failure
will be triggered. NOTE: this number needs to be bigger than 0 (1 and up). 
""" ,
  "JobCleanup"     :\
"""
FailureArchive : If jobs fail to many times you want to tar the job cache and move it
to another location (dir) for post mortem inspection and to minimize the risk of the 
job cache directory growing to large (to many files) and slowing down production.
SuccessArchive : After a job successfully finishes remainders of its log files
are tarred and moved to an archive for possible post mortem analysis.
"""  
    }

if componentList == []:
    componentList = componentFields.keys()

print "Writing Config File: %s" % configFile
print "Using Components:"
for item in componentList:
    print "  ",item

if os.path.exists(configFile):
    print "Config File Already Exists: %s" % configFile
    backup = "%s.BAK.%s" % (configFile, _Timestamp)
    os.system("/bin/cp %s %s" % (configFile, backup))
    print "Config File backed up to:"
    print " ", backup



config = ProdAgentConfiguration()

#  //
# // Process core fields
#//
for name, values in coreFields.items():
    cfgDict = config.getConfig(name)
    cfgDict.update(values)
    if comments.has_key(name):
        cfgDict.comment = comments[name]


prodAgentBlock = config.getConfig("ProdAgent")

# NOTE: boss post processing
# NOTE: needs to be done better (how, withouth designating BOSS a component?)
cfgDict = config.getConfig("BOSS")
cfgDict['configDir']=os.path.join(prodAgentBlock['ProdAgentWorkDir'],"BOSS/config")


def processField(fieldName, fieldDict):
    """
    _processField_

    for a given field create a config component for it

    """
    cfg = config.newComponentConfig(fieldName)
    cfg.update(fieldDict)
    if comments.has_key(fieldName):
        cfg.comment = comments[fieldName]

    #  //
    # // Ensure that ComponentDir param is always the unholy
    #//  union of ProdAgent['ProdAgentWorkDir'] and the component
    #  //name. That is it cannot be set by the user.
    # //
    #//
    cfg['ComponentDir'] = os.path.join(prodAgentBlock['ProdAgentWorkDir'],
                                       fieldName)
    
    return

#  //
# // Process components
#//
for component in componentList:
    compDict = componentFields.get(component, None)
    if compDict == None:
        msg = "Unknown Component: %s\n" % component
        msg += "Valid Components are:\n"
        msg += "%s\n" % componentFields.keys()
        print msg
        sys.exit(1)

        
    processField(component, compDict)


#  //
# // Save config file
#//
config.saveToFile(configFile)



#  //
# // Generate plugin configs
#//
os.system("prodAgent-new-pluginconfig")







